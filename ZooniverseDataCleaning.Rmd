---
title: "Zooniverse Data Cleaning"
author: "Emily Long"
date: "4/13/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Let's Get Started!

Since our Zooniverse data is a bit messy, we're going to need more functions from some special R packages. If you can't find a function in R's inbuilt functions to accomplish something, Google it! Someone has probably made a helpful package for you.  

**Tidyverse** is the powerhouse package for all things data science, including data cleaning and plotting. We'll need the package **jsonlite** because the participant responses from our Zooniverse data is exported in a JSON format. The package **strex** has some really helpful string cleaning functions.

```{r libraries, message=FALSE}
# use install.packages("library name") if you haven't installed them yet
library(tidyverse)
library(jsonlite)
library(strex)
```

Let's load the data. We are going to save our data as a **dataframe** called **classes**. Note that in R, the '<-' symbol is like an equals sign. So we are assigning 'variable_name <- values_and_stuff'. Since our data set has column names already, we specify 'header = TRUE' in our read.csv function. 

```{r pressure}
classes <- read.csv("heritage-combs-classifications.csv",header = TRUE)
```

Note: this data is test data generated by myself, so don't try to draw any statistical conclusions from it.

### Some R Basics: Indexing

Before we get ahead of ourselves, here are some quick R basics to get everyone up to speed. The little **c** function creates a vector. Using a colon : creates a vector of sequential integers. You can combine this sequence into a larger vector with c. 

```{r vector}
1:3
c(6,8,12)
c(1:3,6,8,12,13)
```

We have our **dataframe** called classes, which is essentially our spreadsheet in R form. What if we only want to see certain rows or columns in the dataframe? You can **index** a dataframe using square brackets: dataframe[rows, columns]. 

If you want to see all of the rows, just say dataframe[ ,columns], or similarly, to see all of the columns dataframe[rows, ]. You can also get a column with its name by using dataframe$column_name.

```{r data_index}
# The value in the first row and second column
classes[1,2]
# The values in the first and third rows + second and sixth columns
classes[c(1,3),c(2,6)]
# Getting a column by its name. The head function shows the first couple of entries (3 here).
head(classes$user_name,3)
```

### Back to Zooniverse:

Which columns do we really need from our dataframe? 

```{r colnames}
colnames(classes)
```

Useful columns:

* **classification_id:** a unique ID for each row.
* **user_name:** the Zooniverse username if someone is logged in, or an anonymous name based on the user's anonymised IP address.
* **user_id:** only logged-in users are given an id number from Zooniverse, but we'll work on this column.
* **workflow_name:** the name of the workflow as defined in Zooniverse.
* **created_at:** time that the participant started completing the question.
* **annotations:** the participant's responses to the questions.
* **subject_data:** has the file name of the images, and also retirement data for when the image is eventually retired.

Columns that aren't useful for this project:

* **user_ip:** the user's anonymised IP address. We'll use the user_name instead.
* **workflow_id:** number unique to each workflow as defined in Zooniverse. We'll use the workflow_name column instead.
* **workflow_version:** a number that's updated each time a workflow is edited in Zooniverse. A good column to eliminate your test data from your final data, but we don't need it for this test dataset.
* **gold_standard & expert:** columns to indicate if the participant is one of your best volunteers.
* **metadata:** information about the participants computer set-up, e.g., window size.
* **subject_ids:** number assigned to the subject/image, but we have our own comb numbers in the file name, so we'll use those instead.

Let's only use the ones we need, because we'll be breaking apart the annotations into lots of columns. Here's where we can use our dataframe indexing to keep only the columns we want!

```{r good_colums}
# Only keeping classification_id, user_name, user_id, workflow_name, created_at, annotations, and subject_data
classes <- classes[,c(1:3,6,8,12,13)]
```

### Removing Users: 

If you've been double-checking or testing the set-up of your Zooniverse project, the data from you and your team's tests will be in your data export. To remove the data from particular users, add their names to the vector below.

```{r remove_users}
# Create a vector of the user names you want to remove
user_rem <- c('bad.user','bad.user2')
# Remove these users from the dataframe
classes <- classes[-which(classes$user_name %in% user_rem),]
# Reset your row indices 
rownames(classes) <- NULL
```

* The function 'which(x)' gives the row numbers for which the condition x is true.
* The function '%in%' is true if the user name is in our bad user names vector.
* The '-' sign tells R to **not** include the rows from 'which(x)'.

After those rows were removed, all the rows still have their old row numbers. Reset that quickly by setting the rownames to 'NULL'. 

### User IDs:

Zooniverse only assigns an id number for a user if they're logged in, but we want to fully anonymise this data and remove the user_name column. 

First, use the **unique** function to get a vector of the user names without repeats.

```{r unique_users}
users <- unique(classes[,2])
users
```

So how do we go about giving these different users a number, especially if we have hundreds of users, and their responses overlap? Let's try a **for loop**! A for loop is a way of repeating a chunk of code a certain number of times. In this case, the for loop will pull out a participant as 'u' from the users vector, assign them a user_id for all of their rows, and then move on to the next user.

```{r user_id}
# Start the user number count at 1
user_num <- 1
# The for loop should iterate over all of our users
for (u in users) {
  # Reassign user_id (column 3) of the classes dataframe to be the new user number
  classes[classes$user_name == u,3] <- user_num
  # Add one to the number for the next user
  user_num = user_num + 1
}
```

Let's look at a few rows to double check that this worked.

```{r user_id2}
classes[1:8,1:3]
```

Now, let's anonymise our data by removing the user_name column, and saving it as a new dataframe **classA**.

```{r anon}
classA <- classes[,-2]
```

### Extracting Values from the JSON Format:

#### Participant Responses

We asked five questions to people in Zooniverse, and they're called T0 to T5 in the Zooniverse output. We'll use those as our column names, but feel free to change yours to something more descriptive.

* T0: decoration
* T1: damage
* T2: aesthetic value
* T3: historic value 
* T4: display
* T5: comments

Now for the messy part. This is what a user's response is to a single subject or comb image from our dataset looks like:

```{r messy}
# The first row and fifth column (annotations)
classA[1,5]
```

To get the responses out of the JSON format, we'll use the function **fromJSON**. This function does a great job of separating out the values we need from the junk.

```{r oneJSON}
fromJSON(classA[1,5])
```

But we only want the information in the **value** column. Below we have the scores from the first four questions, their answer to the display question, and the last value is empty because they didn't leave a comment.

```{r twoJSON}
fromJSON(classA[1,5])$value
```

The caveat of this function is that we'll have to use it row-by-row for our dataframe, so we'll use another for loop. Create a variable **n** to represent the number of rows in our classA dataframe. 

```{r newCols}
# First, find out how many rows are with the dim (dimension) function
n <- dim(classA)[1]
n
# The for loop will go through the rows one-by-one down the dataframe
for (i in 1:n) {
  # Extracting a vector of this row's responses and saving it into 6 new columns
  classA[i,7:12] <- fromJSON(classA[i,5])$value
}
```

Let's rename the columns to match our T0 through T5 code.

```{r annotate}
colnames(classA)
colnames(classA)[7:12] <- c('T0','T1','T2','T3','T4','T5')
classA[1:2,7:12]
```

For T0 through T3, we have answers on a 1-5 scale, and for analysis, it can be helpful to save only the integer values. The function **substr(x,1,1)** grabs only the first character in a string, and the function **as.integer** converts the string to an integer value. This for loop will repeat the process for columns 7 through 10 (T0 through T3).

```{r fourJSON}
for (i in 7:10) {
  classA[,i] <- as.integer(substr(classA[,i],1,1))
}
classA[1:2,c(1:3,7:12)]
```

#### File Names

Now there's one more JSON column that we need to get the filename information from. If your image hasn't been 'retired' in Zooniverse yet - meaning that enough people have completed the task so you consider it completed - this column doesn't look too bad. But the retirement info can make it even messier!

```{r subdata}
classA$subject_data[1:2]
```

The main issue with column though is that the subject id number is added to the beginning (e.g. 57028442), so this number is then in the column name of fromJSON (\$'56620723'\$Filename), and it would be harder to loop over all the rows. 

```{r moresub}
fromJSON(classA$subject_data[1])

```

So we will manually remove this part of the string with **substr** and replace the old subject_data values. The function **nchar** outputs the number of characters in a string, and nchar(x) - 1 will stop before the last '}' on the end of the string.

```{r 2sub}
# Removing the first 13 characters and the last } from the string so we can get to the file name
classA$subject_data <- substr(classA$subject_data, 13, nchar(classA$subject_data)-1)
classA$subject_data[1:2]
```

Then we can create a new column for the filename (e.g., combs1A.png). 

```{r mostsub}
# creating new empty character column for file names
classA$filename <- rep("",n)
# for loop to extract file names from column
for (i in 1:n) {
  classA[i,13] <- fromJSON(classA[i,6])$Filename
}
```

The most important part of the file name for our experiment is the comb number, so we can extract it with the function **str_first_number** from the **strex** package. Note that our images in the test set are only numbered from 1-5, but str_first_number('combs120B.png') will output 120 as desired.

```{r combnum}
classA$comb_num <- str_first_number(classA$filename)
```

Since we don't need them anymore, let's remove the JSON columns annotations and subject_data (5 and 6).

```{r remcol}
classA <- classA[,-c(5,6)]
```

#### Clean Up Workflow Name

One last thing, we can extract the A/B from the workflow name, so that columns a bit cleaner.

```{r work}
classA$workflow_name <- substr(classA$workflow_name,9,9)
```

VoilÃ ! Now the data is cleaned up and ready to be analyzed. You can export the updated dataframe with the write_csv function. 

```{r shebeautiful}
# write_csv(classA,"cleanedCombData.csv")

classA[1:5,]
```
